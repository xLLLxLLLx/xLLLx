### Contest 7

[Codeforces1109-Round#539Div1](https://codeforces.com/contest/1109)

[å®˜æ–¹é¢˜è§£](https://codeforces.com/blog/entry/65295)



---------------

æ€»ä¹‹æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆzzdå¤§ç¥è¯´è¿™åœºå¾ˆå¥½æ¶¨åˆ†qwq

å¤§æ¦‚æ˜¯æœ‰ä¸€é“è‚¥è‚ å¥—è·¯çš„Eï¼Ÿï¼Ÿï¼ˆ~~å¥½æ¶¨åˆ†ä¹Ÿä¸å¦¨ç¢æˆ‘gg~~

Aé¢˜ç®€ç›´å°±æ˜¯~~è¶…çº§å¤§æ°´é¢˜ã€‚ã€‚æ€ä¹ˆdiv2Cå˜æˆè¿™ä¸ªæ ·å­qwq~~

Bé¢˜ä¹Ÿæ˜¯é“ç»“è®ºé¢˜çš„æ ·å­å‘¢ã€‚ã€‚å¯æˆ‘ç«Ÿç„¶æœ‰ä¸€ç§æ›´ä¼˜çš„æ–¹æ¡ˆæ²¡æƒ³åˆ°ã€‚ã€‚(~~æ™ºå•†ç›´çº¿ä¸‹æ»‘~~

Cé¢˜å°±æ˜¯é“æ— è‰¯æ•°æ®ç»“æ„é¢˜ã€‚ã€‚åæ­£å°±æ˜¯~~é‚£ç§é“ç†æˆ‘éƒ½æ‡‚å•¥ä¹Ÿä¸ä¼šå†™çš„æ„Ÿè§‰~~

Dé¢˜tmåˆæ˜¯é“ç»“è®ºé¢˜ã€‚ã€‚ä¸è¿‡è¿™ä¸ªç»“è®ºå¥½ç¥å•Šï¼è€Œä¸”åº”ç”¨ä¹Ÿå¾ˆç¥ä»™å•Šã€‚ã€‚ï¼ˆæ„Ÿè§‰å°±åƒæ˜¯æˆ‘çŸ¥é“æœ‰è¿™ä¹ˆä¸€ä¸ªç»“è®ºä¹Ÿè¿˜æ˜¯ä¸ä¼šåšçš„æ„Ÿè§‰ã€‚ã€‚

Eé¢˜ã€‚ã€‚çº¿æ®µæ ‘æš´å†™é¢˜ã€‚ã€‚ä¸»è¦è¿˜æ˜¯å¤„ç†æ¨¡æ•°ä¸æ˜¯è´¨æ•°çš„æ—¶å€™ã€‚ã€‚ç”¨åˆ°äº†ç‚¹CRTåˆå¹¶

Fé¢˜ã€‚ã€‚tmåˆæ˜¯æ•°æ®ç»“æ„ï¼LCT+çº¿æ®µæ ‘ï¼åŠ ä¸Šæˆ‘çš„ç¥å¥‡ç é£ 200+è¡Œã€‚ã€‚

~~æˆ‘èƒ½è¯´ä»€ä¹ˆã€‚ã€‚è¿™åœºç®€ç›´å°±æ˜¯æ¯’ç˜¤å¥½å—ã€‚ã€‚ã€‚~~

------

ç»ˆäºåˆ°äº†æ„‰å¿«çš„å†™é¢˜è§£ç¯èŠ‚ï¼ˆå¹¶ä¸

#### A

å¤ªæ°´äº†æˆ‘ä»¬ç›´æ¥è·³è¿‡

#### B

å¥½ä¸€é“ç‰›é€¼çš„é¢˜ç›®ã€‚ã€‚ã€‚

æ³¨æ„åˆ°ä¸€ç‚¹ æœ€æé™çš„æƒ…å†µä¸‹ æˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰çš„å­—æ¯éƒ½æ‹†å‡ºæ¥ï¼

ç„¶åæ— è§£çš„æƒ…å†µå¾ˆæ˜¾ç„¶äº†

ç„¶ååœ¨æœ‰è§£çš„æƒ…å†µä¸‹ æˆ‘ä»¬æœ€å¤šä¹Ÿåªç”¨åˆ‡2åˆ€å°±ä¸€å®šå¯ä»¥äº† è€Œä¸”è‡³å°‘ä¹Ÿè¦åˆ‡1åˆ€

ç„¶åå¯¹äºé•¿åº¦ä¸ºå¶æ•°çš„å­—ç¬¦ä¸² å¦‚æœä¸­é—´åˆ‡å¼€ ä¸¤è¾¹å¦‚æœä¸æ˜¯å›æ–‡ä¸²çš„è¯ é‚£ä¹ˆå°±æ˜¯1åˆ€å•¦ï½

#### C

> æŒ‰é¢˜æ„æ¨¡æ‹Ÿä¸€ä¸‹å˜›ã€‚ã€‚

çº¿æ®µæ ‘å¹³è¡¡æ ‘æŒ‘ä¸€ä¸ªå†™å†™ï¼ˆåæ­£ä¸¤ä¸ªéƒ½ä¸ä¼šå¥½å†™åˆ°å“ªé‡Œå»ã€‚ã€‚

çº¿æ®µæ ‘å¯èƒ½å¥½å†™ä¸€ç‚¹ï¼Ÿï¼ˆä¸è¿‡æˆ‘æ„Ÿè§‰çº¿æ®µæ ‘çš„é¢„å¤„ç†æ¯”è¾ƒéº»çƒ¦

#### D

> ç»“è®ºé¢˜ã€‚ã€‚ã€‚

ä¸¢å‡ ä¸ªé“¾æ¥ğŸ”—

[Cold_Chair](https://blog.csdn.net/Cold_Chair/article/details/87558803)  	[ymzqwq](https://blog.csdn.net/ymzqwq/article/details/87633376)		[è®ºæ–‡](https://www.sciencedirect.com/science/article/pii/0097316590900644?via%3Dihub)

é¦–å…ˆå‘¢ ä½œä¸ºæ™ºå•†ä¸æ˜¯è´Ÿæ•°çš„æ³¥ å‘ç°

ä½ å¯ä»¥æšä¸¾$a,b$ä¹‹é—´æœ‰å¤šå°‘æ¡è¾¹å•Š æˆ‘ä»¬è®¾ä¸º$x$

æœ‰$x$æ¡è¾¹å°±è¯´æ˜æˆ‘ä»¬è¦é€‰$x-1$ä¸ªç‚¹ $A_{n-2}^{x-1}$

åˆè¾¹çš„å’Œä¸º$m$ åˆ™ç”±æŒ¡æ¿æ³• å¯å¾—$C_{m-1}^{x-1}$

å…¶ä»–è¾¹éšæ„$m^{n-1-x}$
$$
ans=æ ‘çš„ä¸ªæ•°*A_{n-2}^{x-1}*C_{m-1}^{x-1}*m^{n-1-x}
$$
**æ‹“å±•Cayleyå…¬å¼**

è®¾$F(n,m)$è¡¨ç¤º$n$ä¸ªç‚¹ç»„æˆ$m$ä¸ªæœ‰æ ‡å·çš„æ£®æ—çš„ä¸ªæ•°ï¼Œ$1-m$å±äºä¸åŒçš„æ ‘
$$
F(n,m)=m*n^{n-1-m}
$$
**prÃ¼feråºåˆ—**

[Martrix67!!!!å†™å¾—è¶…çº§å¥½ï¼ï¼](http://www.matrix67.com/blog/archives/682)

#### E

> äº‹å®ä¸Šã€‚ã€‚ä½ å¯ä»¥æŠŠè¿™ä¸ª<font color="blue">**æ¨¡æ•°ç»™è´¨å› æ•°åˆ†è§£ä¸€ä¸‹**</font>ã€‚ã€‚
> $$
> p = p_1^{k_1}p_2^{k_2}p_3^{k_3}â€¦*p_t^{k_t}
> $$
> æŠŠæ‰€æœ‰è¦æ“ä½œçš„æ•°$w$ éƒ½å˜æˆ
> $$
> w=v*p_1^{l_1}*p2^{l_2}...*p_t^{l_t}
> $$
> å…¶ä¸­$v$å’Œ$p$äº’è´¨ é‚£ä¹ˆ$v$å°±æ‹¥æœ‰æ¨¡$p$æ„ä¹‰ä¸‹çš„é€†å…ƒå•¦ï¼



çœ‹åˆ°é¢˜ç›®æ³¥ä¼šå‘ç° 1ï¼Œ3ä¸¤ä¸ªæ“ä½œã€‚ã€‚ä½ éšä¾¿å†™é¢—çº¿æ®µæ ‘å°±å¯ä»¥äº†

å¦‚æœæ¨¡æ•°æ˜¯ä¸ªè´¨æ•°çš„è¯ 1ï¼Œ2ï¼Œ3éƒ½å¯ä»¥éšä¾¿å†™é¢—çº¿æ®µæ ‘äº†ã€‚ã€‚ã€‚

ä½†æ˜¯ è¿™ä¸ªæ¨¡æ•°ä¸æ˜¯ä¸ªè´¨æ•°ã€‚ã€‚ã€‚é‚£å°±å¹¶ä¸æ˜¯æ¯ä¸€ä¸ªæ•°éƒ½æœ‰åœ¨è†œpæ„ä¹‰ä¸‹çš„é€†å…ƒäº†ã€‚ã€‚

äº‹å®ä¸Šã€‚ã€‚ä½ å¯ä»¥æŠŠè¿™ä¸ª<font color="blue">**æ¨¡æ•°ç»™è´¨å› æ•°åˆ†è§£ä¸€ä¸‹**</font>ã€‚ã€‚
$$
p = p_1^{k_1}p_2^{k_2}p_3^{k_3}â€¦*p_t^{k_t}
$$
æŠŠæ‰€æœ‰è¦æ“ä½œçš„æ•°$w$ éƒ½å˜æˆ
$$
w=v*p_1^{l_1}*p2^{l_2}...*p_k^{l_k}
$$
å…¶ä¸­$v$å’Œ$p$äº’è´¨ é‚£ä¹ˆ$v$å°±æ‹¥æœ‰æ¨¡$p$æ„ä¹‰ä¸‹çš„é€†å…ƒå•¦ï¼

çº¿æ®µæ ‘ç›´æ¥ç»´æŠ¤è¿™äº›ä¸œè¥¿å°±è¡Œäº†



#### F

> åˆ¤æ–­æ˜¯å¦æ˜¯æ ‘çš„æ—¶å€™ æˆ‘ä»¬å¯ä»¥å…ˆåˆ¤æ–­æ˜¯å¦æ˜¯æ£®æ— ç„¶åå†åˆ¤æ–­ç‚¹æ•°-è¾¹æ•°æ˜¯å¦ç­‰äº1

æˆ‘ä»¬å¯ä»¥å‘ç°å¯¹äºä¸€ä¸ª$l$ å­˜åœ¨ä¸€ä¸ªæœ€å¤§çš„$r$ä½¿å¾—$(l,r)$æ˜¯ä¸€ä¸ªæ£®æ—ï¼Œ$r->r+1$æ—¶å°±ä¼šæœ‰ç¯å‡ºç°

ä¸”$l ->l +1$æ—¶ $r$ä¸ä¼šå˜å° ç±»ä¼¼äºtwo-pointerå¤„ç†ä¸€ä¸‹å°±è¡Œå•¦

æ€ä¹ˆæ ·å¯ä»¥å¿«é€Ÿåˆ¤ç¯ï¼Ÿäº¤ç»™lctï¼

å¦‚ä½•æ±‚å¾—åŒºé—´ç‚¹æ•°-è¾¹æ•°çš„æœ€å°å€¼ å’Œæœ€å°å€¼æœ‰å‡ ä¸ªï¼Ÿ äº¤ç»™çº¿æ®µæ ‘ï¼



------------

ä»£ç åŒºï¼ˆ~~æ€»ä¹‹æˆ‘è§‰å¾—è‡ªå·±çš„ä»£ç å†™çš„è‚¥è‚ å¥½çœ‹è€Œä¸”æµ…æ˜¾æ˜“æ‡‚~~

##### A

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 3e5 + 10, M = 2e6 + 10;
int a[M][2];

int main() {
	int n, now = 0;
	scanf("%d", &n);
	ll ans = 0;
	a[0][0]++;
	for(int i = 1, x; i <= n; ++i) {
		scanf("%d", &x);
		now ^= x;
		int pos = i & 1;
		ans += a[now][pos];
		a[now][pos]++;
		// printf("%d %d\n", i, now);
	}
	printf("%lld\n", ans);
	return 0;
}
```

##### B

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5010;
char lx[N];

void fail() {
	printf("Impossible\n");
	exit(0);
}

bool check(int l, int r) {
	for(int i = l; i <= r; ++i) {
		if(lx[i] != lx[r - i + l]) return false;
	}
	return true;
}

bool go(int x) {
	if(x & 1) return true;
	int mid = x / 2;
	if(check(1, mid)) {
		return go(mid);
	} else return false;
}

int main() {
	scanf("%s", lx + 1);
	int len = strlen(lx + 1);
	if(len == 1) fail();
	int flg = 1, pos = lx[1] - 'a' + 1;
	if(len & 1) {
		for(int i = 1; i <= len; ++i) {
			if(i == len / 2 + 1) continue;
			if(lx[i] - 'a' + 1 != pos) flg = 0;
		}
	} else {
		for(int i = 1; i <= len; ++i) {
			if(lx[i] - 'a' + 1 != pos) flg = 0;
		}
	}
	if(flg) fail();
	else {
		if(len & 1) {
			printf("2\n");
		} else {
			if(go(len)) printf("2\n");
				else printf("1\n");
		}
	} 
	return 0;
}
```

##### C

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 10, inf = 1e9;
struct data {
	ll tr, tl, sr, s, t, res, minn;
	int rd, ch[2];
	void print() {
		printf("tr=%d tl=%d sr=%d s=%d t=%d res=%d minn=%d ls=%d rs=%d\n", rd,tr,tl,sr,s,t,res,minn,ch[0],ch[1]); 
	}
} t[N];

void up(int x) {
	if(t[x].ch[0]) {
		t[x].tl = t[t[x].ch[0]].tl;
	} else t[x].tl = t[x].t;
	if(t[x].ch[1]) {
		t[x].tr = t[t[x].ch[1]].tr;
		t[x].sr = t[t[x].ch[1]].sr;
	} else {
		t[x].tr = t[x].t;
		t[x].sr = t[x].s;
	}
	t[x].res = 0, t[x].minn = 0;
	if(t[x].ch[0]) {
		t[x].minn = max(t[x].minn, t[t[x].ch[0]].minn);
		t[x].res += t[t[x].ch[0]].res;
		t[x].res += t[t[x].ch[0]].sr * (t[x].t - t[t[x].ch[0]].tr);
		t[x].minn = max(t[x].minn, -t[x].res);
	}
	if(t[x].ch[1]) {
		t[x].res += t[x].s * (t[t[x].ch[1]].tl - t[x].t);
		t[x].minn = max(t[x].minn, -t[x].res);
		t[x].minn = max(t[x].minn, -t[x].res + t[t[x].ch[1]].minn);
		t[x].res += t[t[x].ch[1]].res;
	}
}

void split(int now, int &x, int &y, ll k) {
	if(!now) {
		x = y = 0;
		return ;
	}
	if(t[now].t <= k) {
		x = now, split(t[now].ch[1], t[now].ch[1], y, k);
	} else {
		y = now, split(t[now].ch[0], x, t[now].ch[0], k);
	}
	up(now);
}

int merge(int x, int y) {
	if(!x || !y) return x ^ y;
	if(t[x].rd < t[y].rd) {
		t[x].ch[1] = merge(t[x].ch[1], y);
		up(x);
		return x;
	} else {
		t[y].ch[0] = merge(x, t[y].ch[0]);
		up(y);
		return y;
	}
}

double ask(int x, ll w) {
	if(t[x].ch[0]) {
		if(w <= t[t[x].ch[0]].minn) {
			return ask(t[x].ch[0], w);
		}
		w += t[t[x].ch[0]].res;
		if(w + t[t[x].ch[0]].sr * (t[x].t - t[t[x].ch[0]].tr) <= 0) {
			return t[t[x].ch[0]].tr - (double)w / t[t[x].ch[0]].sr;
		}
		w += t[t[x].ch[0]].sr * (t[x].t - t[t[x].ch[0]].tr);
	}
	if(t[x].ch[1]) {
		if(w + t[x].s * (t[t[x].ch[1]].tl - t[x].t) <= 0) {
			return t[x].t - (double)w / t[x].s;
		}
		w += t[x].s * (t[t[x].ch[1]].tl - t[x].t);
		return ask(t[x].ch[1], w);
	}
	return t[x].t - (double)w / t[x].s;
}

int main() {
	srand(time(NULL));
	int n, root = 0, cnt = 0, dx, dy, dz, dw;
	scanf("%d", &n);
	for(int i = 1, opt; i <= n; ++i) {
		scanf("%d", &opt);
		// printf("root=%d\n", root);
		if(opt == 1) {
			++cnt;
			scanf("%lld%lld", &t[cnt].t, &t[cnt].s);
			t[cnt].tl = t[cnt].tr = t[cnt].t;
			t[cnt].sr = t[cnt].s;
			t[cnt].rd = rand() % inf;
			t[cnt].ch[0] = t[cnt].ch[1] = 0;
			split(root, dx, dy, t[cnt].t);
			root = merge(merge(dx, cnt), dy);
		} else if(opt == 2) {
			int l;
			scanf("%lld", &l);
			split(root, dx, dy, l);
			split(dx, dz, dw, l - 1);
			root = merge(dz, dy);
		} else {
			ll l, r, w;
			scanf("%lld%lld%lld", &l, &r, &w);
			if(!w) {
				printf("%.8f\n", double(l));
				continue;
			}
			split(root, dx, dy, r);
			split(dx, dz, dw, l - 1);
			if(!dw) {
				printf("-1\n");
			} else if(w > t[dw].minn) {
				w += t[dw].res;
				if(w + (r - t[dw].tr) * t[dw].sr <= 0) {
					printf("%.8f\n", t[dw].tr - (double)w / t[dw].sr);
				} else printf("-1\n");
			} else printf("%.8f\n", ask(dw, w));
			root = merge(merge(dz, dw), dy);
		}
	}
	return 0;
}
```

##### D

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 10, mod = 1e9 + 7;
ll jc[N] = {1}, ny[N] = {1};

ll q_pow(ll x, int y) {
	ll ans = 1;
	for(; y; y >>= 1) {
		if(y & 1) {
			ans = ans * x % mod;
		}
		x = x * x % mod;
	}
	return ans;
}

ll C(int x, int y) {
	if(y > x) return 0ll;
	return jc[x] * ny[y] % mod * ny[x - y] % mod;
}

ll A(int x, int y) {
	return jc[x] * ny[x - y] % mod;
}

int main() {
	int n, m, a, b;
	cin >> n >> m >> a >> b;
	ll ans = 0;
	for(int i = 1; i < N; ++i) jc[i] = jc[i - 1] * i % mod, ny[i] = q_pow(jc[i], mod - 2);
	for(int i = 1; i <= n - 1; ++i) {
		ll pos = A(n - 2, i - 1) * q_pow(m, n - 1 - i) % mod * C(m - 1, i - 1) % mod;
		if(i != n - 1) pos = pos * (i + 1) % mod * q_pow(n, n - i - 2) % mod;
		ans = (ans + pos) % mod;
	}
	printf("%lld\n", ans);
	return 0;
}
```

##### E

```c++
#include <bits/stdc++.h>
#define ll long long
#define ls x << 1
#define rs x << 1 | 1
using namespace std;
const int N = 1e5 + 10;
ll tr[N << 2][20], tag[N << 2], sum[N << 2];
int yz[15], c[15], val[N];
int mod, phi;

ll mul(ll x, ll y) {
	return x * y % mod;
}

ll add(ll x, ll y) {
	return (x + y) % mod;
}

void Add(ll &x, ll y) {
	x = (x + y) % mod;
}

void Mul(ll &x, ll y) {
	x = (x * y) % mod;
}

ll q_pow(ll x, int y) {
	ll ans = 1;
	for(; y; y >>= 1) {
		if(y & 1) Mul(ans, x);
		Mul(x, x);
	}
	return ans;
}

ll rev(ll x) {
	return q_pow(x, phi - 1);
}

void getphi(int x) {
	int len = sqrt(x);
	phi = x;
	for(int i = 2; i <= len; ++i) {
		if(x % i == 0) {
			yz[++yz[0]] = i;
			phi = phi / i * (i - 1);
			while(x % i == 0) x /= i;
		}
	}
	if(x > 1) yz[++yz[0]] = x, phi = phi / x * (x - 1);
}

void get(int x, int &y) {
	memset(c, 0, sizeof c);
	for(int i = 1; i <= yz[0]; ++i) {
		while(x % yz[i] == 0) {
			x /= yz[i], c[i]++;
		}
	}
	y = x % mod;
}

ll cal(int x) {
	ll ans = 1;
	for(int i = 1; i <= yz[0]; ++i) {
		Mul(ans, q_pow(yz[i], tr[x][i]));
	}
	return ans;
}

void up(int x) {
	sum[x] = add(sum[ls], sum[rs]);
}

void down(int x) {
	ll pos = cal(x);
	for(int i = 1; i <= yz[0]; ++i) {
		tr[ls][i] += tr[x][i];
		tr[rs][i] += tr[x][i];
		tr[x][i] = 0;
	}
	Mul(tag[ls], tag[x]), Mul(sum[ls], mul(tag[x], pos));
	Mul(tag[rs], tag[x]), Mul(sum[rs], mul(tag[x], pos));
	tag[x] = 1;
}

void build(int x, int l, int r) {
	tag[x] = 1;
	if(l == r) {
		sum[x] = val[l] % mod;
		for(int i = 1; i <= yz[0]; ++i) {
			while(val[l] % yz[i] == 0) {
				val[l] /= yz[i];
				tr[x][i]++;
			}
		}
		tag[x] = val[l] % mod;
		return ;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
	up(x);
}

void modify(int x, int l, int r, int L, int R, ll real, ll v) {
	if(L <= l && r <= R) {
		for(int i = 1; i <= yz[0]; ++i) {
			tr[x][i] += c[i];
		}
		Mul(tag[x], v);
		Mul(sum[x], real);
		return ;
	}
	down(x);
	int mid = (l + r) >> 1;
	if(L <= mid) modify(ls, l, mid, L, R, real, v);
	if(R > mid) modify(rs, mid + 1, r, L, R, real, v);
	up(x);
}

void change(int x, int l, int r, int L, ll v) {
	if(l == r) {
		for(int i = 1; i <= yz[0]; ++i) {
			tr[x][i] -= c[i];
		}
		Mul(tag[x], rev(v));
		sum[x] = mul(cal(x), tag[x]);
		return ;
	}
	down(x);
	int mid = (l + r) >> 1;
	if(L <= mid) change(ls, l, mid, L, v);
	else change(rs, mid + 1, r, L, v);
	up(x);
}

ll ask(int x, int l, int r, int L, int R) {
	if(L <= l && r <= R) {
		return sum[x];
	}
	down(x);
	int mid = (l + r) >> 1;
	ll ans1 = 0, ans2 = 0;
	if(L <= mid) ans1 = ask(ls, l, mid, L, R);
	if(R > mid) ans2 = ask(rs, mid + 1, r, L, R);
	return add(ans1, ans2);
}

int main() {
	int n;
	scanf("%d%d", &n, &mod);
	getphi(mod);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &val[i]);
	}
	build(1, 1, n);
	int q;
	scanf("%d", &q);
	for(int i = 1; i <= q; ++i) {
		int opt;
		scanf("%d", &opt);
		if(opt == 1) {
			int l, r, real, v;
			scanf("%d%d%d", &l, &r, &real);
			get(real, v);
			modify(1, 1, n, l, r, real, v);
		} else if(opt == 2) {
			int p, real, v;
			scanf("%d%d", &p, &real);
			get(real, v);
			change(1, 1, n, p, v);
		} else {
			int l, r;
			scanf("%d%d", &l, &r);
			printf("%lld\n", ask(1, 1, n, l, r) % mod);
		}
	}
	return 0;
}
```

##### F

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1001, M = 2e5 + 1;

/* LCT */
struct LCT {
	int f[M], ch[M][2];
	bool rev[M];

	#define ls ch[x][0]
	#define rs ch[x][1]

	bool isroot(int x) {
		return (ch[f[x]][0] != x) && (ch[f[x]][1] != x);
	}

	void Rev(int x) {
		swap(ls, rs);
		rev[x] ^= 1;
	}

	void down(int x) {
		if(rev[x]) {
			Rev(ls), Rev(rs);
			rev[x] = 0;
		}
	}

	void pushdown(int x) {
		if(f[x]) pushdown(f[x]);
		down(x);
	}

	void rotate(int x) {
		int y = f[x], z = f[y], k = (ch[z][1] == y), d = (ch[y][1] == x);
		if(!isroot(y)) {
			ch[z][k] = x;
		}
		f[x] = z;
		ch[y][d] = ch[x][d ^ 1], f[ch[x][d ^ 1]] = y;
		ch[x][d ^ 1] = y, f[y] = x;
	}

	void splay(int x) {
		pushdown(x);
		while(!isroot(x)) {
			int y = f[x], z = f[y];
			if(!isroot(y)) 
				(ch[z][1] == y) ^ (ch[y][1] == x) ? rotate(x) : rotate(y);
			rotate(x);
		}
	}

	void access(int x) {
		for(int y = 0; x; y = x, x = f[x]) {
			splay(x);
			rs = y;
		}
	}

	void makeroot(int x) {
		access(x);
		splay(x);
		Rev(x);
	}

	int findroot(int x) {
		access(x);
		splay(x);
		for(; ls; down(x), x = ls) {
			splay(x);
		}
		return x;
	}

	void split(int x, int y) {
		makeroot(x);
		access(y);
		splay(y);
	}

	void link(int x, int y) {
		makeroot(x), f[x] = y;
	}

	void cut(int x, int y) {
		split(x, y), f[x] = ch[y][0] = 0;
	}
} T;

/* LCT */

/* segtree */

#define lson x << 1
#define rson x << 1 | 1
int sum[M << 2], tag[M << 2], v[M << 2];

int maxn, num;

void up(int x) {
	v[x] = min(v[lson], v[rson]), sum[x] = 0;
	if(v[lson] == v[x]) sum[x] += sum[lson];
	if(v[rson] == v[x]) sum[x] += sum[rson];
}

void down(int x) {	
	if(tag[x]) {
		tag[lson] += tag[x], v[lson] += tag[x];
		tag[rson] += tag[x], v[rson] += tag[x];
		tag[x] = 0;
	}
}

void check(int x) {
	if(v[x] < maxn) {
		maxn = v[x], num = sum[x];
	} else if(v[x] == maxn) {
		num += sum[x];
	}
}

void build(int x, int l, int r) {
	if(l == r) {
		sum[x] = r - l + 1;
		v[x] = 0;
		return ;
	}
	int mid = (l + r) >> 1;
	build(lson, l, mid), build(rson, mid + 1, r);
	up(x);
}

void change(int x, int l, int r, int L, int R, int w) {
	if(L <= l && r <= R) {
		tag[x] += w;
		v[x] += w;
		return ;
	}
	down(x);
	int mid = (l + r) >> 1;
	if(L <= mid) change(lson, l, mid, L, R, w);
	if(R > mid) change(rson, mid + 1, r, L, R, w);
	up(x);
}

void ask(int x, int l, int r, int L, int R) {
	if(L <= l && r <= R) {
		check(x);
		return ;
	}
	down(x);
	int mid = (l + r) >> 1;
	if(L <= mid) ask(lson, l, mid, L, R);
	if(R > mid) ask(rson, mid + 1, r, L, R);
	up(x);
}
/* segtree */

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
int a[N][N], idx[M], idy[M];

int n, m, nowl = 1, nowr = 1, p[10];

bool judge() {
	p[0] = 0;
	for(int i = 0; i < 4; ++i) {
		int x = idx[nowr + 1] + dx[i], y = idy[nowr + 1] + dy[i];
		if(!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {
			continue;
		}
		p[++p[0]] = T.findroot(a[x][y]);
	}
	sort(p + 1, p + 1 + p[0]);
	for(int i = 1; i < p[0]; ++i) if(p[i] == p[i + 1]) return false;
	return true;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) 
		for(int j = 1; j <= m; ++j) {
			scanf("%d", &a[i][j]);
			idx[a[i][j]] = i, idy[a[i][j]] = j;
		}
	build(1, 1, n * m), change(1, 1, n * m, 1, 1, 1);
	ll ans = 1;
	for(; nowr < n * m; ) {
		for(; nowl < nowr && !judge(); ++nowl) {
			for(int i = 0; i < 4; ++i) {
				int x = idx[nowl] + dx[i], y = idy[nowl] + dy[i];
				if(!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {
					continue;
				}
				T.cut(nowl, a[x][y]);
			}
		}
		++nowr, change(1, 1, n * m, nowl, nowr, 1);
		for(int i = 0; i < 4; ++i) {
			int x = idx[nowr] + dx[i], y = idy[nowr] + dy[i];
			if(!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {
					continue;
			}
			T.link(nowr, a[x][y]), change(1, 1, n * m, nowl, a[x][y], -1);
		}
		maxn = 1e9, num = 0;
		ask(1, 1, n * m, nowl, nowr);
		ans += (maxn == 1) * num;
	}
	printf("%I64d\n", ans);
	return 0;
}
```

